package templates

import (
	"context"
	"fmt"
	"log"

	"github.com/google/go-github/v60/github"
)

// Generator handles workflow template generation and PR creation
type Generator struct {
	client   *github.Client
	registry *Registry
}

// NewGenerator creates a new template generator
func NewGenerator(client *github.Client) *Generator {
	return &Generator{
		client:   client,
		registry: NewRegistry(),
	}
}

// NewGeneratorWithRegistry creates a generator with a custom registry
func NewGeneratorWithRegistry(client *github.Client, registry *Registry) *Generator {
	return &Generator{
		client:   client,
		registry: registry,
	}
}

// GenerateWorkflowContent renders a template to workflow YAML content
func (g *Generator) GenerateWorkflowContent(templateID string, ctx *TemplateContext) (string, error) {
	return g.registry.Generate(templateID, ctx)
}

// ApplyResult contains the result of applying a template
type ApplyResult struct {
	TemplateID string `json:"template_id"`
	Org        string `json:"org"`
	Repo       string `json:"repo"`
	PRNumber   int    `json:"pr_number,omitempty"`
	PRURL      string `json:"pr_url,omitempty"`
	BranchName string `json:"branch_name"`
	FilePath   string `json:"file_path"`
	Success    bool   `json:"success"`
	Error      string `json:"error,omitempty"`
	DirectPush bool   `json:"direct_push,omitempty"`
}

// ApplyOptions configures how a template is applied
type ApplyOptions struct {
	// CreatePR creates a pull request instead of direct push
	CreatePR bool
	// BranchName override (default: buildguard/add-{template-id})
	BranchName string
	// CommitMessage override
	CommitMessage string
	// PRTitle override
	PRTitle string
	// PRBody override
	PRBody string
}

// Apply generates a workflow from a template and creates a PR to add it
func (g *Generator) Apply(ctx context.Context, org, repo, templateID string, tmplCtx *TemplateContext, opts *ApplyOptions) (*ApplyResult, error) {
	if opts == nil {
		opts = &ApplyOptions{CreatePR: true}
	}

	result := &ApplyResult{
		TemplateID: templateID,
		Org:        org,
		Repo:       repo,
	}

	// Get template
	tmpl, err := g.registry.Get(templateID)
	if err != nil {
		result.Error = err.Error()
		return result, err
	}

	// Generate content
	content, err := g.registry.Generate(templateID, tmplCtx)
	if err != nil {
		result.Error = err.Error()
		return result, err
	}

	// Determine file path
	filePath := fmt.Sprintf(".github/workflows/%s.yml", templateID)
	result.FilePath = filePath

	// Get default branch
	repoInfo, _, err := g.client.Repositories.Get(ctx, org, repo)
	if err != nil {
		result.Error = fmt.Sprintf("failed to get repo info: %v", err)
		return result, err
	}
	baseBranch := repoInfo.GetDefaultBranch()
	if baseBranch == "" {
		baseBranch = "main"
	}

	// Branch name
	branchName := opts.BranchName
	if branchName == "" {
		branchName = fmt.Sprintf("blueprint/add-%s", templateID)
	}
	result.BranchName = branchName

	if opts.CreatePR {
		// Create branch and PR
		prResult, err := g.createWorkflowPR(ctx, org, repo, baseBranch, branchName, filePath, content, tmpl, opts)
		if err != nil {
			result.Error = err.Error()
			return result, err
		}
		result.PRNumber = prResult.PRNumber
		result.PRURL = prResult.PRURL
		result.Success = true
	} else {
		// Direct push to default branch
		if err := g.directPush(ctx, org, repo, baseBranch, filePath, content, opts); err != nil {
			result.Error = err.Error()
			return result, err
		}
		result.DirectPush = true
		result.Success = true
	}

	return result, nil
}

type prResult struct {
	PRNumber int
	PRURL    string
}

func (g *Generator) createWorkflowPR(ctx context.Context, org, repo, baseBranch, branchName, filePath, content string, tmpl *WorkflowTemplate, opts *ApplyOptions) (*prResult, error) {
	// 1. Get base branch ref
	ref, _, err := g.client.Git.GetRef(ctx, org, repo, "refs/heads/"+baseBranch)
	if err != nil {
		return nil, fmt.Errorf("failed to get base branch ref: %w", err)
	}

	// 2. Create new branch
	newRef := &github.Reference{
		Ref:    strPtr("refs/heads/" + branchName),
		Object: &github.GitObject{SHA: ref.Object.SHA},
	}
	_, _, err = g.client.Git.CreateRef(ctx, org, repo, newRef)
	if err != nil {
		// Branch might already exist, try to continue
		log.Printf("Branch %s may already exist: %v", branchName, err)
	}

	// 3. Commit the workflow file
	commitMsg := opts.CommitMessage
	if commitMsg == "" {
		commitMsg = fmt.Sprintf("ci: add %s workflow\n\nGenerated by Blueprint", tmpl.Name)
	}

	fileOpts := &github.RepositoryContentFileOptions{
		Message: strPtr(commitMsg),
		Content: []byte(content),
		Branch:  strPtr(branchName),
	}

	// Check if file already exists on branch
	existingFile, _, _, _ := g.client.Repositories.GetContents(ctx, org, repo, filePath, &github.RepositoryContentGetOptions{Ref: branchName})
	if existingFile != nil {
		fileOpts.SHA = strPtr(existingFile.GetSHA())
	}

	_, _, err = g.client.Repositories.UpdateFile(ctx, org, repo, filePath, fileOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to commit workflow file: %w", err)
	}

	// 4. Create PR
	prTitle := opts.PRTitle
	if prTitle == "" {
		prTitle = fmt.Sprintf("Add %s workflow", tmpl.Name)
	}

	prBody := opts.PRBody
	if prBody == "" {
		prBody = g.generatePRBody(tmpl, filePath)
	}

	pr := &github.NewPullRequest{
		Title: strPtr(prTitle),
		Head:  strPtr(branchName),
		Base:  strPtr(baseBranch),
		Body:  strPtr(prBody),
	}

	createdPR, _, err := g.client.PullRequests.Create(ctx, org, repo, pr)
	if err != nil {
		return nil, fmt.Errorf("failed to create PR: %w", err)
	}

	return &prResult{
		PRNumber: createdPR.GetNumber(),
		PRURL:    createdPR.GetHTMLURL(),
	}, nil
}

func (g *Generator) directPush(ctx context.Context, org, repo, branch, filePath, content string, opts *ApplyOptions) error {
	commitMsg := opts.CommitMessage
	if commitMsg == "" {
		commitMsg = "ci: add workflow (Blueprint)"
	}

	fileOpts := &github.RepositoryContentFileOptions{
		Message: strPtr(commitMsg),
		Content: []byte(content),
		Branch:  strPtr(branch),
	}

	// Check if file exists
	existingFile, _, _, _ := g.client.Repositories.GetContents(ctx, org, repo, filePath, &github.RepositoryContentGetOptions{Ref: branch})
	if existingFile != nil {
		fileOpts.SHA = strPtr(existingFile.GetSHA())
	}

	_, _, err := g.client.Repositories.UpdateFile(ctx, org, repo, filePath, fileOpts)
	return err
}

func (g *Generator) generatePRBody(tmpl *WorkflowTemplate, filePath string) string {
	body := fmt.Sprintf(`## %s

%s

### Compliance Frameworks
`, tmpl.Name, tmpl.Description)

	for _, f := range tmpl.Frameworks {
		body += fmt.Sprintf("- %s\n", f)
	}

	body += fmt.Sprintf("\n### Changes\n- Added `%s`\n\n### Category\n%s\n\n---\nGenerated by [Blueprint](https://github.com/build-flow-labs/blueprint)\n", filePath, tmpl.Category)

	return body
}

// ListTemplates returns all available templates from the registry
func (g *Generator) ListTemplates() []*WorkflowTemplate {
	return g.registry.List()
}

// GetTemplate returns a specific template by ID
func (g *Generator) GetTemplate(id string) (*WorkflowTemplate, error) {
	return g.registry.Get(id)
}

func strPtr(s string) *string {
	return &s
}
