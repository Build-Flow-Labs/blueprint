package setup

import (
	"context"
	"crypto/rand"
	"embed"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"strings"

	gh "github.com/build-flow-labs/blueprint/internal/pbom/github"
	"gopkg.in/yaml.v3"
)

//go:embed templates/pbom-collector.yml
var embeddedFS embed.FS

// ------------------------------------------------------------------
// Step 1: Validate GitHub access
// ------------------------------------------------------------------

func (w *Wizard) validateAccess(ctx context.Context) error {
	// Verify org access
	org, err := w.ghClient.GetOrg(ctx, w.org)
	if err != nil {
		return fmt.Errorf("cannot access org %q: %w", w.org, err)
	}
	w.record("Validate access", "ok", fmt.Sprintf("Org: %s (plan: %s)", org.Login, org.Plan.Name))

	// Check token scopes
	scopes, err := w.ghClient.GetTokenScopes(ctx)
	if err != nil {
		return fmt.Errorf("cannot read token scopes: %w", err)
	}
	if len(scopes) > 0 {
		w.record("Validate access", "ok", fmt.Sprintf("Token scopes: %s", strings.Join(scopes, ", ")))
	} else {
		w.record("Validate access", "ok", "Token scopes: fine-grained token (scopes not listed)")
	}

	return nil
}

// ------------------------------------------------------------------
// Step 2: Create custom properties
// ------------------------------------------------------------------

func (w *Wizard) createCustomProperties(ctx context.Context) error {
	properties := []struct {
		Name string
		Def  gh.CustomPropertyDef
	}{
		{
			Name: "pbom-enabled",
			Def: gh.CustomPropertyDef{
				ValueType:   "true_false",
				Required:    false,
				Description: "Enable PBOM pipeline metadata collection",
			},
		},
		{
			Name: "tier",
			Def: gh.CustomPropertyDef{
				ValueType:     "single_select",
				Required:      false,
				Description:   "Repository tier for deployment classification",
				AllowedValues: []string{"production", "staging", "development"},
			},
		},
		{
			Name: "lifecycle",
			Def: gh.CustomPropertyDef{
				ValueType:     "single_select",
				Required:      false,
				Description:   "Repository lifecycle stage",
				AllowedValues: []string{"active", "deprecated", "experimental"},
			},
		},
	}

	for _, prop := range properties {
		if w.dryRun {
			w.record("Custom properties", "dry-run", fmt.Sprintf("Would create property: %s (%s)", prop.Name, prop.Def.ValueType))
			continue
		}
		err := w.ghClient.CreateCustomProperty(ctx, w.org, prop.Name, prop.Def)
		if err != nil {
			w.record("Custom properties", "error", fmt.Sprintf("Failed to create %s: %v", prop.Name, err))
		} else {
			w.record("Custom properties", "created", fmt.Sprintf("%s (%s)", prop.Name, prop.Def.ValueType))
		}
	}

	return nil
}

// ------------------------------------------------------------------
// Step 3: Generate filter config
// ------------------------------------------------------------------

type filterConfig struct {
	Version   string        `yaml:"version"`
	Filtering filterSection `yaml:"filtering"`
}

type filterSection struct {
	DefaultAction string       `yaml:"default_action"`
	Rules         []filterRule `yaml:"rules"`
}

type filterRule struct {
	Property string   `yaml:"property"`
	Value    string   `yaml:"value,omitempty"`
	Values   []string `yaml:"values,omitempty"`
	Action   string   `yaml:"action"`
}

// configYAML holds the generated config bytes after step 3.
var configYAML []byte

func (w *Wizard) generateConfig(ctx context.Context) error {
	choice := w.prompt.askChoice(
		"Filtering strategy:",
		[]string{
			"Opt-in (safe: only explicitly matched repos get PBOM)",
			"Opt-out (all repos get PBOM unless excluded)",
		},
	)

	cfg := filterConfig{
		Version: "1.0",
		Filtering: filterSection{
			DefaultAction: "exclude",
		},
	}

	if choice == 0 {
		// Opt-in: default exclude, include by property
		cfg.Filtering.Rules = []filterRule{
			{Property: "pbom-enabled", Value: "true", Action: "include"},
			{Property: "tier", Values: []string{"production", "staging"}, Action: "include"},
			{Property: "lifecycle", Value: "deprecated", Action: "exclude"},
		}
	} else {
		// Opt-out: default include, exclude by property
		cfg.Filtering.DefaultAction = "include"
		cfg.Filtering.Rules = []filterRule{
			{Property: "pbom-enabled", Value: "false", Action: "exclude"},
			{Property: "lifecycle", Value: "deprecated", Action: "exclude"},
			{Property: "lifecycle", Value: "experimental", Action: "exclude"},
		}
	}

	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("marshaling config: %w", err)
	}

	header := "# pbom-config.yml - Generated by pbom init\n# Rules are evaluated top-to-bottom, first match wins.\n\n"
	configYAML = append([]byte(header), data...)

	w.record("Filter config", "generated", fmt.Sprintf("default_action: %s, %d rules", cfg.Filtering.DefaultAction, len(cfg.Filtering.Rules)))
	return nil
}

// ------------------------------------------------------------------
// Step 4: Push files to .github repo
// ------------------------------------------------------------------

func (w *Wizard) pushToGitHubRepo(ctx context.Context) error {
	repoName := ".github"

	// Check if .github repo exists
	_, err := w.ghClient.GetOrg(ctx, w.org) // just verifying access
	if err != nil {
		return fmt.Errorf("cannot verify .github repo access: %w", err)
	}

	// Push pbom-config.yml
	if err := w.pushFile(ctx, w.org, repoName, "pbom-config.yml", "Add PBOM filter configuration", configYAML); err != nil {
		w.record("Push files", "error", fmt.Sprintf("pbom-config.yml: %v", err))
	}

	// Push collector workflow
	workflowContent, err := embeddedFS.ReadFile("templates/pbom-collector.yml")
	if err != nil {
		return fmt.Errorf("reading embedded workflow template: %w", err)
	}
	if err := w.pushFile(ctx, w.org, repoName, ".github/workflows/pbom-collector.yml", "Add PBOM Collector workflow", workflowContent); err != nil {
		w.record("Push files", "error", fmt.Sprintf("pbom-collector.yml: %v", err))
	}

	return nil
}

func (w *Wizard) pushFile(ctx context.Context, owner, repo, path, message string, content []byte) error {
	encoded := base64.StdEncoding.EncodeToString(content)

	if w.dryRun {
		w.record("Push files", "dry-run", fmt.Sprintf("Would push %s to %s/%s", path, owner, repo))
		return nil
	}

	// Check if file already exists (to get SHA for update)
	var sha string
	existing, err := w.ghClient.GetFileContents(ctx, owner, repo, path)
	if err == nil {
		sha = existing.SHA
		w.record("Push files", "updated", fmt.Sprintf("%s (updating existing)", path))
	} else {
		w.record("Push files", "created", path)
	}

	return w.ghClient.CreateOrUpdateFileContents(ctx, owner, repo, path, message, encoded, sha)
}

// ------------------------------------------------------------------
// Step 5: Create org webhook
// ------------------------------------------------------------------

// webhookSecret holds the generated secret after step 5.
var webhookSecret string

func (w *Wizard) createWebhook(ctx context.Context) error {
	webhookURL := w.prompt.askDefault("Webhook URL", "https://example.com/webhook")
	if webhookURL == "" || webhookURL == "https://example.com/webhook" {
		if !w.prompt.askYesNo("No webhook URL set. Skip webhook creation?", true) {
			return fmt.Errorf("webhook URL required")
		}
		w.record("Webhook", "skipped", "No URL provided")
		return nil
	}

	// Check for existing webhooks
	existing, err := w.ghClient.ListOrgWebhooks(ctx, w.org)
	if err == nil {
		for _, hook := range existing {
			if hook.Config.URL == webhookURL {
				w.record("Webhook", "skipped", fmt.Sprintf("Already exists (ID: %d)", hook.ID))
				return nil
			}
		}
	}

	// Generate secret
	secretBytes := make([]byte, 32)
	if _, err := rand.Read(secretBytes); err != nil {
		return fmt.Errorf("generating webhook secret: %w", err)
	}
	webhookSecret = hex.EncodeToString(secretBytes)

	if w.dryRun {
		w.record("Webhook", "dry-run", fmt.Sprintf("Would create webhook for %s", webhookURL))
		return nil
	}

	hookCfg := gh.WebhookConfig{
		Name:   "web",
		Active: true,
		Events: []string{"workflow_run"},
		Config: gh.WebhookEndpoint{
			URL:         webhookURL,
			ContentType: "json",
			Secret:      webhookSecret,
			InsecureSSL: "0",
		},
	}

	resp, err := w.ghClient.CreateOrgWebhook(ctx, w.org, hookCfg)
	if err != nil {
		return fmt.Errorf("creating webhook: %w", err)
	}

	w.record("Webhook", "created", fmt.Sprintf("ID: %d, URL: %s", resp.ID, webhookURL))
	fmt.Fprintf(w.out, "\n  WEBHOOK SECRET (save this!):\n  %s\n\n", webhookSecret)
	return nil
}

// ------------------------------------------------------------------
// Step 6: Set repo properties (optional)
// ------------------------------------------------------------------

func (w *Wizard) setRepoProperties(ctx context.Context) error {
	if !w.prompt.askYesNo("Set custom properties on repos now?", false) {
		w.record("Repo properties", "skipped", "User declined")
		return nil
	}

	repos, err := w.ghClient.ListRepos(ctx, w.org)
	if err != nil {
		return fmt.Errorf("listing repos: %w", err)
	}

	if len(repos) == 0 {
		w.record("Repo properties", "skipped", "No repos found")
		return nil
	}

	names := make([]string, len(repos))
	for i, r := range repos {
		names[i] = r.Name
	}

	selected := w.prompt.askMultiSelect("Select repos to enable PBOM:", names)
	if len(selected) == 0 {
		w.record("Repo properties", "skipped", "No repos selected")
		return nil
	}

	selectedNames := make([]string, len(selected))
	for i, idx := range selected {
		selectedNames[i] = names[idx]
	}

	// Ask for tier
	tierIdx := w.prompt.askChoice("Tier for selected repos:", []string{"production", "staging", "development"})
	tiers := []string{"production", "staging", "development"}

	props := map[string]string{
		"pbom-enabled": "true",
		"tier":         tiers[tierIdx],
		"lifecycle":    "active",
	}

	if w.dryRun {
		w.record("Repo properties", "dry-run", fmt.Sprintf("Would set properties on %d repos: %s", len(selectedNames), strings.Join(selectedNames, ", ")))
		return nil
	}

	err = w.ghClient.SetRepoCustomProperties(ctx, w.org, selectedNames, props)
	if err != nil {
		return fmt.Errorf("setting properties: %w", err)
	}

	w.record("Repo properties", "created", fmt.Sprintf("Set on %d repos (tier=%s)", len(selectedNames), tiers[tierIdx]))
	return nil
}

// ------------------------------------------------------------------
// Step 7: Print summary
// ------------------------------------------------------------------

func (w *Wizard) printSummary() {
	fmt.Fprintln(w.out, "")
	fmt.Fprintln(w.out, "  ===========================")
	fmt.Fprintln(w.out, "  PBOM Setup Complete")
	fmt.Fprintln(w.out, "  ===========================")
	fmt.Fprintln(w.out, "")

	for _, r := range w.results {
		icon := "  [+]"
		switch r.Action {
		case "skipped":
			icon = "  [-]"
		case "dry-run":
			icon = "  [~]"
		case "error":
			icon = "  [!]"
		case "ok":
			icon = "  [v]"
		}
		fmt.Fprintf(w.out, "%s %s: %s\n", icon, r.Step, r.Detail)
	}

	fmt.Fprintln(w.out, "")
	fmt.Fprintln(w.out, "  Next steps:")
	fmt.Fprintln(w.out, "  -----------")
	if webhookSecret != "" {
		fmt.Fprintf(w.out, "  1. Start the webhook listener:\n     pbom webhook --secret %s --token $GITHUB_TOKEN\n\n", webhookSecret)
	} else {
		fmt.Fprintln(w.out, "  1. Start the webhook listener:")
		fmt.Fprintln(w.out, "     pbom webhook --secret <your-secret> --token $GITHUB_TOKEN")
		fmt.Fprintln(w.out, "")
	}
	fmt.Fprintln(w.out, "  2. Push to a repo with PBOM enabled to trigger collection")
	fmt.Fprintln(w.out, "  3. View the dashboard at http://localhost:8080/ui")
	fmt.Fprintln(w.out, "")
}
