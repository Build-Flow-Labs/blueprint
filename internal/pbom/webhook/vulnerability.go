package webhook

import (
	"archive/zip"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"strings"
	"time"

	gh "github.com/build-flow-labs/blueprint/internal/pbom/github"
	"github.com/build-flow-labs/blueprint/pbom/schema"
)

// TrivyReport represents the top-level Trivy JSON output.
type TrivyReport struct {
	Results []TrivyResult `json:"Results"`
}

// TrivyResult is a single scan target (OS packages, language libs, etc.).
type TrivyResult struct {
	Target          string               `json:"Target"`
	Vulnerabilities []TrivyVulnerability `json:"Vulnerabilities"`
}

// TrivyVulnerability is a single CVE entry from Trivy.
type TrivyVulnerability struct {
	VulnerabilityID string `json:"VulnerabilityID"`
	Severity        string `json:"Severity"`
}

// ExtractVulnerabilities finds trivy-report-* artifacts from a workflow run,
// downloads them, and returns vulnerability counts.
func ExtractVulnerabilities(ctx context.Context, client *gh.Client, owner, repo string, runID int64, logger *slog.Logger) *schema.Vulnerabilities {
	artifacts, err := client.GetArtifacts(ctx, owner, repo, runID)
	if err != nil {
		logger.Warn("failed to get artifacts for vuln scan", "error", err)
		return nil
	}

	for _, art := range artifacts {
		if !strings.HasPrefix(art.Name, "trivy-report-") {
			continue
		}

		report, err := downloadAndParseTrivyReport(ctx, client, art.ArchiveDownloadURL)
		if err != nil {
			logger.Warn("failed to parse Trivy report", "name", art.Name, "error", err)
			continue
		}

		return countVulnerabilities(report)
	}

	return nil
}

// countVulnerabilities tallies CVEs by severity from a Trivy report.
func countVulnerabilities(report *TrivyReport) *schema.Vulnerabilities {
	now := time.Now().UTC()
	vulns := &schema.Vulnerabilities{
		Scanner:   "trivy",
		ScannedAt: &now,
	}

	for _, result := range report.Results {
		for _, v := range result.Vulnerabilities {
			switch strings.ToUpper(v.Severity) {
			case "CRITICAL":
				vulns.Critical++
			case "HIGH":
				vulns.High++
			case "MEDIUM":
				vulns.Medium++
			case "LOW":
				vulns.Low++
			}
		}
	}

	return vulns
}

func downloadAndParseTrivyReport(ctx context.Context, client *gh.Client, downloadURL string) (*TrivyReport, error) {
	zipData, err := client.DownloadArtifact(ctx, downloadURL)
	if err != nil {
		return nil, fmt.Errorf("downloading artifact: %w", err)
	}

	reader, err := zip.NewReader(bytes.NewReader(zipData), int64(len(zipData)))
	if err != nil {
		return nil, fmt.Errorf("opening zip: %w", err)
	}

	for _, f := range reader.File {
		if strings.HasSuffix(f.Name, ".json") {
			rc, err := f.Open()
			if err != nil {
				return nil, fmt.Errorf("opening %s: %w", f.Name, err)
			}
			defer rc.Close()

			var report TrivyReport
			if err := json.NewDecoder(rc).Decode(&report); err != nil {
				return nil, fmt.Errorf("parsing %s: %w", f.Name, err)
			}
			return &report, nil
		}
	}

	return nil, fmt.Errorf("no JSON file found in Trivy report zip")
}
